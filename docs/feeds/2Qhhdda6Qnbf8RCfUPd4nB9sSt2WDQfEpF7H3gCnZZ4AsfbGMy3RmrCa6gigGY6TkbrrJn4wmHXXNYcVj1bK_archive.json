{
  "id": "2Qhhdda6Qnbf8RCfUPd4nB9sSt2WDQfEpF7H3gCnZZ4AsfbGMy3RmrCa6gigGY6TkbrrJn4wmHXXNYcVj1bK",
  "title": "top scoring links : rust",
  "displayTitle": "Reddit - Rust",
  "url": "https://www.reddit.com/r/rust/top/.rss?sort=top&t=day&limit=6",
  "feedLink": "https://www.reddit.com/r/rust/top/?sort=top&t=day&limit=6",
  "is_query": false,
  "items": [
    {
      "title": "Visualizing memory layout of Rust's data types",
      "url": "https://www.reddit.com/r/rust/comments/1hp3xjm/visualizing_memory_layout_of_rusts_data_types/",
      "date": 1735501283,
      "author": "/u/EventHelixCom",
      "unread": true,
      "content": "&#32; submitted by &#32; <a href=\"https://www.reddit.com/user/EventHelixCom\"> /u/EventHelixCom </a> <br/> <span><a href=\"https://youtu.be/7_o-YRxf_cc?si=6__TBBF1wcln_JOJ\">[link]</a></span> &#32; <span><a href=\"https://www.reddit.com/r/rust/comments/1hp3xjm/visualizing_memory_layout_of_rusts_data_types/\">[comments]</a></span>",
      "flags": null,
      "enclosureUrl": "",
      "enclosureMime": ""
    },
    {
      "title": "refinement types & units of measure revisited",
      "url": "https://www.reddit.com/r/rust/comments/1howvp9/refinement_types_units_of_measure_revisited/",
      "date": 1735481859,
      "author": "/u/gclichtenberg",
      "unread": true,
      "content": "<!-- SC_OFF --><div class=\"md\"><p>In response to <a href=\"https://www.reddit.com/r/rust/comments/1hkkn2u/what_would_it_take_to_let_users_add_refinement/\">this earlier post</a>, a crate that <a href=\"https://github.com/bwo/units-poc\">features a minimal type-level system for doing what the author wants</a>. This is really just an illustration of some type-level programming: the <a href=\"https://docs.rs/uom/latest/uom/index.html\"><code>uom</code></a> crate actually knows what units of measure <em>are</em>, Ã  la Frink.</p> </div><!-- SC_ON --> &#32; submitted by &#32; <a href=\"https://www.reddit.com/user/gclichtenberg\"> /u/gclichtenberg </a> <br/> <span><a href=\"https://www.reddit.com/r/rust/comments/1howvp9/refinement_types_units_of_measure_revisited/\">[link]</a></span> &#32; <span><a href=\"https://www.reddit.com/r/rust/comments/1howvp9/refinement_types_units_of_measure_revisited/\">[comments]</a></span>",
      "flags": null,
      "enclosureUrl": "",
      "enclosureMime": ""
    },
    {
      "title": "NNN: a new take on nutype",
      "url": "https://www.reddit.com/r/rust/comments/1hovz1p/nnn_a_new_take_on_nutype/",
      "date": 1735478771,
      "author": "/u/vic1707_2",
      "unread": true,
      "content": "<!-- SC_OFF --><div class=\"md\"><p>Hi,</p> <p>TL/DR: I made a library to create new-types with guarantees <a href=\"https://github.com/vic1707/nnn\">https://github.com/vic1707/nnn</a></p> <p>A few months ago I stumbled upon nutype (<a href=\"https://github.com/greyblake/nutype\">https://github.com/greyblake/nutype</a>) and absolutely loved it.</p> <p>I started using it everywhere I could and made sense, encountered a few issues, contributed a bit but I was missing some features, conditional derives <a href=\"https://github.com/greyblake/nutype/issues/188\">https://github.com/greyblake/nutype/issues/188</a> and one to be able to make associated consts: <a href=\"https://github.com/greyblake/nutype/issues/35\">https://github.com/greyblake/nutype/issues/35</a> . I proposed a solution for the latter which got rightfully rejected.</p> <p>Another issue I had was the overwhelming complexity of the nutype code, I got lost a few times reading it and felt that some limitations were maybe unnecessary.</p> <p>So I decided to try to make my own proc-macro inspired by nutype during my free-time over 3 weeks.</p> <p>I&#39;m very happy with the results and would love to get your advices about the project, the code etc...</p> <p>The crate allows you to declare newtypes like this and doesn&#39;t enforce much on you beside syntax and obvious footguns. ```rs use nnn::nnn;</p> <h1>[nnn(</h1> <pre><code>derive(Debug, PartialEq, Eq, PartialOrd, Ord), nnn_derive(TryFrom), consts( ZERO = 0.0_f64, pub ONE = 1.0_f64, ), default = 5.0_f64, validators(finite, positive), sanitizers(custom = |v: f64| v.abs()), // Serialize &amp; Deserialize are only available in test env. cfg(test, derive(Serialize, Deserialize)), attrs( repr(transparent), ), </code></pre> <p>)] struct PositiveFiniteFloat(f64); ``` Hope you&#39;ll like it !</p> </div><!-- SC_ON --> &#32; submitted by &#32; <a href=\"https://www.reddit.com/user/vic1707_2\"> /u/vic1707_2 </a> <br/> <span><a href=\"https://www.reddit.com/r/rust/comments/1hovz1p/nnn_a_new_take_on_nutype/\">[link]</a></span> &#32; <span><a href=\"https://www.reddit.com/r/rust/comments/1hovz1p/nnn_a_new_take_on_nutype/\">[comments]</a></span>",
      "flags": null,
      "enclosureUrl": "",
      "enclosureMime": ""
    },
    {
      "title": "Maurice, a new Thomson MO5 emulator written in Rust",
      "url": "https://www.reddit.com/r/rust/comments/1hot1a1/maurice_a_new_thomson_mo5_emulator_written_in_rust/",
      "date": 1735466695,
      "author": "/u/kpouer",
      "unread": true,
      "content": "<!-- SC_OFF --><div class=\"md\"><p>Hey,</p> <p>Just sharing a little project: my Thomson MO5 emulator called Maurice. The Thomson MO5 was a French computer from the 80s that was very successful in France and probably nowhere else. My goal here was to learn Rust, and I thought it would be an interesting project to port an emulator to Rust and learn what it can do in the desktop application domain.</p> <p>For context, it is a port of an existing MO5 emulator called Marcel o Cinq, which exists in C and Java. Of course, it is free and open source, just like the original emulator I was porting.</p> <p>Note that I am not an expert in emulation and am completely open to comments and suggestions about it or about my code.</p> <p>source and compiled binaries for Mac and Windows available here (It can run on Linux too of course however I did not test already)</p> <p><a href=\"https://github.com/kpouer/Maurice\">https://github.com/kpouer/Maurice</a></p> <p><a href=\"https://preview.redd.it/kc6mfhw9hr9e1.png?width=320&amp;format=png&amp;auto=webp&amp;s=4957c246b13dd02b469dc03317ffa6ea32601b51\">https://preview.redd.it/kc6mfhw9hr9e1.png?width=320&amp;format=png&amp;auto=webp&amp;s=4957c246b13dd02b469dc03317ffa6ea32601b51</a></p> </div><!-- SC_ON --> &#32; submitted by &#32; <a href=\"https://www.reddit.com/user/kpouer\"> /u/kpouer </a> <br/> <span><a href=\"https://www.reddit.com/r/rust/comments/1hot1a1/maurice_a_new_thomson_mo5_emulator_written_in_rust/\">[link]</a></span> &#32; <span><a href=\"https://www.reddit.com/r/rust/comments/1hot1a1/maurice_a_new_thomson_mo5_emulator_written_in_rust/\">[comments]</a></span>",
      "flags": null,
      "enclosureUrl": "",
      "enclosureMime": ""
    },
    {
      "title": "What is \"bad\" about Rust?",
      "url": "https://www.reddit.com/r/rust/comments/1hoqc4v/what_is_bad_about_rust/",
      "date": 1735454840,
      "author": "/u/BestMat-Inc",
      "unread": true,
      "content": "<!-- SC_OFF --><div class=\"md\"><p>Hello fellow Rustaceans,</p> <p>I have been using Rust for quite a while now and am making a programming language in Rust. I pondered for some time about what Rust is bad about (to try to fix them in my language) and got these points:</p> <ol> <li>Verbose Syntax</li> <li>Slow Compilation Time</li> <li>Inefficient compatibility with C. (Yes, I know ABI exists but other languages like Zig or C3 does it better)</li> </ol> <p>Please let me know the other &quot;bad&quot; or &quot;difficult&quot; parts about Rust.<br/> Thank you!</p> <p><strong>EDIT:</strong> May I also know how would I fix them in my language.</p> </div><!-- SC_ON --> &#32; submitted by &#32; <a href=\"https://www.reddit.com/user/BestMat-Inc\"> /u/BestMat-Inc </a> <br/> <span><a href=\"https://www.reddit.com/r/rust/comments/1hoqc4v/what_is_bad_about_rust/\">[link]</a></span> &#32; <span><a href=\"https://www.reddit.com/r/rust/comments/1hoqc4v/what_is_bad_about_rust/\">[comments]</a></span>",
      "flags": null,
      "enclosureUrl": "",
      "enclosureMime": ""
    },
    {
      "title": "First Project - Thoth: A terminal scratchpad inspired by Heynote",
      "url": "https://www.reddit.com/r/rust/comments/1hony7j/first_project_thoth_a_terminal_scratchpad/",
      "date": 1735446064,
      "author": "/u/Slight_Touch_8285",
      "unread": true,
      "content": "<!-- SC_OFF --><div class=\"md\"><p><a href=\"https://github.com/jooaf/thoth\">https://github.com/jooaf/thoth</a><br/> Hi all! For my first Rust project I built Thoth, a terminal scratchpad inspired by <a href=\"https://github.com/heyman/heynote\">Heynote</a>. I enjoy working in the terminal, and I love Heynote, so I thought why not make a terminal application like it. </p> <p>I made a post about this several months ago, but just wanted to raise again to see if I can get some feedback and/or any suggestions for improvement. I&#39;m still inexperienced when it comes to Rust, so I&#39;m actively trying to learn as much as I can via building stuff. </p> <p>Thank you all for taking the time to check this out :)!</p> </div><!-- SC_ON --> &#32; submitted by &#32; <a href=\"https://www.reddit.com/user/Slight_Touch_8285\"> /u/Slight_Touch_8285 </a> <br/> <span><a href=\"https://www.reddit.com/r/rust/comments/1hony7j/first_project_thoth_a_terminal_scratchpad/\">[link]</a></span> &#32; <span><a href=\"https://www.reddit.com/r/rust/comments/1hony7j/first_project_thoth_a_terminal_scratchpad/\">[comments]</a></span>",
      "flags": null,
      "enclosureUrl": "",
      "enclosureMime": ""
    },
    {
      "title": "Fish 4.0: The Fish Of Theseus",
      "url": "https://www.reddit.com/r/rust/comments/1hohs2s/fish_40_the_fish_of_theseus/",
      "date": 1735426889,
      "author": "/u/tfmoraes",
      "unread": true,
      "content": "&#32; submitted by &#32; <a href=\"https://www.reddit.com/user/tfmoraes\"> /u/tfmoraes </a> <br/> <span><a href=\"https://fishshell.com/blog/rustport/\">[link]</a></span> &#32; <span><a href=\"https://www.reddit.com/r/rust/comments/1hohs2s/fish_40_the_fish_of_theseus/\">[comments]</a></span>",
      "flags": null,
      "enclosureUrl": "",
      "enclosureMime": ""
    },
    {
      "title": "Veloren 0.17 release party - a 3D voxel-based action MMORPG, written in Rust",
      "url": "https://www.reddit.com/r/rust/comments/1hod2iw/veloren_017_release_party_a_3d_voxelbased_action/",
      "date": 1735413818,
      "author": "/u/kibwen",
      "unread": true,
      "content": "&#32; submitted by &#32; <a href=\"https://www.reddit.com/user/kibwen\"> /u/kibwen </a> <br/> <span><a href=\"https://www.youtube.com/watch?v=kgK58NuBrXc\">[link]</a></span> &#32; <span><a href=\"https://www.reddit.com/r/rust/comments/1hod2iw/veloren_017_release_party_a_3d_voxelbased_action/\">[comments]</a></span>",
      "flags": null,
      "enclosureUrl": "",
      "enclosureMime": ""
    },
    {
      "title": "New to Rust, surprised by runtime panic",
      "url": "https://www.reddit.com/r/rust/comments/1hoat89/new_to_rust_surprised_by_runtime_panic/",
      "date": 1735407763,
      "author": "/u/waterproofsocks",
      "unread": true,
      "content": "<!-- SC_OFF --><div class=\"md\"><p>I&#39;m an experienced programmer but very new to Rust and am still learning where all the resources are for answering questions like this. I am working on a simple starter project to learn the basics, and came across a surprising runtime panic the compiler didn&#39;t catch. I&#39;m wondering why, considering this &#39;index out of bounds&#39; error looks so easy on the surface to verify at compile time. Am I just missing some compiler flags to add these warnings/errors? </p> <pre><code>fn index_out_of_bounds() { let array_of_one = [1]; for i in 0..2 { println!(&quot;{}&quot;, array_of_one[i]); } } </code></pre> </div><!-- SC_ON --> &#32; submitted by &#32; <a href=\"https://www.reddit.com/user/waterproofsocks\"> /u/waterproofsocks </a> <br/> <span><a href=\"https://www.reddit.com/r/rust/comments/1hoat89/new_to_rust_surprised_by_runtime_panic/\">[link]</a></span> &#32; <span><a href=\"https://www.reddit.com/r/rust/comments/1hoat89/new_to_rust_surprised_by_runtime_panic/\">[comments]</a></span>",
      "flags": null,
      "enclosureUrl": "",
      "enclosureMime": ""
    },
    {
      "title": "Data structures for allocating a large number of constant strings that may repeat.",
      "url": "https://www.reddit.com/r/rust/comments/1ho7yv4/data_structures_for_allocating_a_large_number_of/",
      "date": 1735399885,
      "author": "/u/RylanStylin57",
      "unread": true,
      "content": "<!-- SC_OFF --><div class=\"md\"><p>My program loads IDs from RON files. ALOT of IDs. Sometimes those files references IDs in other files. IDs are constant and never change. I need a way to allocate these strings on the heap in a way that minimizes the number of allocations and reu-uses existing allocations if the string has already been used.</p> <p>My idea is to use a Slab with a fixed size to store the characters in the strings and a map to lookup ids to avoid double allocations. But I&#39;m struggling because my RON loaders are parallel and I don&#39;t want to just Mutex the allocator, which would cause an excessive amount of contention. </p> <p><code>rs pub struct ID { // a pointer to somewhere in the allocator // i know this is unsafe, but im enforcing that the // string allocator be static. name: &amp;&#39;static str, hash: u32, } </code></p> <p><code>rs use slab::Slab; // How do I make this work in parallel? pub struct StringAllocator { data: Slab&lt;char&gt;, // map of indexes of already-allocated IDs existing: BTreeMap&lt;u32, usize&gt;, } </code></p> </div><!-- SC_ON --> &#32; submitted by &#32; <a href=\"https://www.reddit.com/user/RylanStylin57\"> /u/RylanStylin57 </a> <br/> <span><a href=\"https://www.reddit.com/r/rust/comments/1ho7yv4/data_structures_for_allocating_a_large_number_of/\">[link]</a></span> &#32; <span><a href=\"https://www.reddit.com/r/rust/comments/1ho7yv4/data_structures_for_allocating_a_large_number_of/\">[comments]</a></span>",
      "flags": null,
      "enclosureUrl": "",
      "enclosureMime": ""
    },
    {
      "title": "What do you think about fish not supporting cygwin and msys2 after using rust?",
      "url": "https://www.reddit.com/r/rust/comments/1ho2kkh/what_do_you_think_about_fish_not_supporting/",
      "date": 1735379502,
      "author": "/u/ahaoboy",
      "unread": true,
      "content": "<!-- SC_OFF --><div class=\"md\"><p>Recently, fish released 4.0b1. When I tried to install it on Windows, I found that fish can only be used in wsl /(ãoã)/~~</p> <p><a href=\"https://github.com/fish-shell/fish-shell/issues/10956\">Please support windows msys2 Â· Issue #10956 Â· fish-shell/fish-shell</a></p> <p>I have no intention to start a wsl vs msys/cygwin or shell war, I&#39;m just a rust beginner, so I want to know the deep reason why fish can&#39;t run on windows, and how to avoid it.</p> </div><!-- SC_ON --> &#32; submitted by &#32; <a href=\"https://www.reddit.com/user/ahaoboy\"> /u/ahaoboy </a> <br/> <span><a href=\"https://www.reddit.com/r/rust/comments/1ho2kkh/what_do_you_think_about_fish_not_supporting/\">[link]</a></span> &#32; <span><a href=\"https://www.reddit.com/r/rust/comments/1ho2kkh/what_do_you_think_about_fish_not_supporting/\">[comments]</a></span>",
      "flags": null,
      "enclosureUrl": "",
      "enclosureMime": ""
    },
    {
      "title": "Bottles will be rewritten in Rust and libcosmic",
      "url": "https://www.reddit.com/r/rust/comments/1ho2b80/bottles_will_be_rewritten_in_rust_and_libcosmic/",
      "date": 1735378304,
      "author": "/u/linAndEd",
      "unread": true,
      "content": "&#32; submitted by &#32; <a href=\"https://www.reddit.com/user/linAndEd\"> /u/linAndEd </a> <br/> <span><a href=\"https://usebottles.com/posts/2024-12-27-rust-libcosmic-next/?s=09\">[link]</a></span> &#32; <span><a href=\"https://www.reddit.com/r/rust/comments/1ho2b80/bottles_will_be_rewritten_in_rust_and_libcosmic/\">[comments]</a></span>",
      "flags": null,
      "enclosureUrl": "",
      "enclosureMime": ""
    },
    {
      "title": "Project Architecture: high CPU and I/O bound tasks",
      "url": "https://www.reddit.com/r/rust/comments/1ho0j9b/project_architecture_high_cpu_and_io_bound_tasks/",
      "date": 1735370293,
      "author": "/u/God_Killer_01",
      "unread": true,
      "content": "<!-- SC_OFF --><div class=\"md\"><p>Hi folks. I&#39;ll be starting a project which has both heavy CPU and I/O bound tasks. I&#39;ll be basically reading seismic data from multiple sources. I need to constantly fetch data from multiple services via protobuf and perform complex math operations/data crunching on it.<br/> I know for I/O parallelization I need tokio and CPU parallelization I need rayon. But do they work well together? I tried searching same on web, and found this:<br/> <a href=\"https://lobste.rs/s/mebxps/mixing_rayon_tokio_for_fun_hair_loss\">https://lobste.rs/s/mebxps/mixing_rayon_tokio_for_fun_hair_loss</a><br/> Looks like it&#39;s not straight-forward. What would be the ideal project architecture here?</p> </div><!-- SC_ON --> &#32; submitted by &#32; <a href=\"https://www.reddit.com/user/God_Killer_01\"> /u/God_Killer_01 </a> <br/> <span><a href=\"https://www.reddit.com/r/rust/comments/1ho0j9b/project_architecture_high_cpu_and_io_bound_tasks/\">[link]</a></span> &#32; <span><a href=\"https://www.reddit.com/r/rust/comments/1ho0j9b/project_architecture_high_cpu_and_io_bound_tasks/\">[comments]</a></span>",
      "flags": null,
      "enclosureUrl": "",
      "enclosureMime": ""
    },
    {
      "title": "Low level books",
      "url": "https://www.reddit.com/r/rust/comments/1hnyu0v/low_level_books/",
      "date": 1735363606,
      "author": "/u/16mb_Gaming_USB",
      "unread": true,
      "content": "<!-- SC_OFF --><div class=\"md\"><p>Iâve heard âlearn a bit of assembly and C to understand computers and program betterâ a lot. I also find I run into a general knowledge barrier when asking âwhyâ too many times about language and program design decisions. Are there any books/resources that can bridge this understanding gap? Any âbiblesâ in this area? Iâm not trying to avoid learning assembly/C, Iâm just more interested in the underlying ideas than the languages themselves. Included examples and crash courses in assembly/C are fine. I get it if the answer is simply âlearn assembly and Câ.</p> </div><!-- SC_ON --> &#32; submitted by &#32; <a href=\"https://www.reddit.com/user/16mb_Gaming_USB\"> /u/16mb_Gaming_USB </a> <br/> <span><a href=\"https://www.reddit.com/r/rust/comments/1hnyu0v/low_level_books/\">[link]</a></span> &#32; <span><a href=\"https://www.reddit.com/r/rust/comments/1hnyu0v/low_level_books/\">[comments]</a></span>",
      "flags": null,
      "enclosureUrl": "",
      "enclosureMime": ""
    },
    {
      "title": "Improving safety in doukutsu-rs NPC list: Request for advice/critique",
      "url": "https://www.reddit.com/r/rust/comments/1hnx9nm/improving_safety_in_doukutsurs_npc_list_request/",
      "date": 1735358181,
      "author": "/u/beholdnec",
      "unread": true,
      "content": "<!-- SC_OFF --><div class=\"md\"><p>I&#39;m an intermediate Rust programmer. Recently I&#39;ve taken an interest in the doukutsu-rs project, a mostly complete re-implementation Cave Story in Rust.</p> <p>Perusing the code, I noticed the memory safety in the engine&#39;s NPC list is severely lacking. It is very easy to create two mutable references to the same NPC, which my Rust knowledge tells me is a safety violation on the level of &quot;your computer might explode&quot;. Basically, it is forbidden.</p> <p>I wrote a PR to improve the safety. Here is a link, starting at src/game/npc/list.rs: <a href=\"https://github.com/doukutsu-rs/doukutsu-rs/pull/296/files#diff-2eb94e5c5ef1c61ce68a44bf8fc00ff9a53a292276577e9c40c40d718913cc93\">https://github.com/doukutsu-rs/doukutsu-rs/pull/296/files#diff-2eb94e5c5ef1c61ce68a44bf8fc00ff9a53a292276577e9c40c40d718913cc93</a></p> <p>Note that the original code uses UnsafeCells to store the NPC&#39;s. The original programmer used this as a somewhat crude way to bypass the borrow checker. There are no guards against taking multiple mutable references to an NPC, and in fact the engine will peek in at mutably borrowed NPC&#39;s to check the &quot;alive&quot; flag.</p> <p>The PR changes the NPC list to use RefCells.</p> <p>On each frame, the game runs through every living NPC and calls a tick function on it. The problem is, the tick function might need to access the NPC list to spawn new NPC&#39;s, kill NPC&#39;s, or change the state of existing NPC&#39;s. This is why NPC&#39;s must be wrapped in Cells. Without cells, borrowing one NPC would cause the entire NPC list to become immutably borrowed and impossible to manipulate.</p> <p>There is an iterator to scan through &quot;alive&quot; NPC&#39;s. Since peeking in at the &quot;alive&quot; flag is impossible while an NPC is borrowed, I made the iterator skip over NPC&#39;s that are borrowed.</p> <p>Before:</p> <p><code>if !npc_ref.cond.alive() {</code></p> <p>After:</p> <p><code>if npc_ref.try_borrow().is_ok_and(|npc_ref| !npc_ref.cond.alive()) {</code></p> <p>The big problem is, there are hundreds of objects in the game and it&#39;s hard to tell if some NPC logic relies on being able to view NPC that is already borrowed. This PR could cause subtle logic errors, which is why I&#39;ve labeled it &quot;do not merge&quot;.</p> <p>I thought about overhauling the NPC tick logic so instead of calling &quot;tick(&amp;mut self, ...)&quot; on the object, it becomes &quot;tick(self_: &amp;RefCell&lt;NPC&gt;&quot;. Then, the NPC logic could drop all its borrows before accessing the NPC list. However, the notion of filling the NPC logic with &quot;borrow()&quot; and &quot;borrow_mut()&quot; is daunting.</p> <p>So I&#39;m asking for advice. What do Rustaceans think of my approach? Is there a better solution I&#39;m missing? How would other Rust programmers tackle this problem?</p> </div><!-- SC_ON --> &#32; submitted by &#32; <a href=\"https://www.reddit.com/user/beholdnec\"> /u/beholdnec </a> <br/> <span><a href=\"https://www.reddit.com/r/rust/comments/1hnx9nm/improving_safety_in_doukutsurs_npc_list_request/\">[link]</a></span> &#32; <span><a href=\"https://www.reddit.com/r/rust/comments/1hnx9nm/improving_safety_in_doukutsurs_npc_list_request/\">[comments]</a></span>",
      "flags": null,
      "enclosureUrl": "",
      "enclosureMime": ""
    },
    {
      "title": "I built a Rails-like parameter parser for Axum - Looking for feedback and contributions",
      "url": "https://www.reddit.com/r/rust/comments/1hnwbut/i_built_a_railslike_parameter_parser_for_axum/",
      "date": 1735355048,
      "author": "/u/Organic_Savings_6128",
      "unread": true,
      "content": "<!-- SC_OFF --><div class=\"md\"><p>Hey Rustaceans! I recently created a parameter parser for Axum that aims to bring Ruby on Rails-like parameter handling to Rust: <a href=\"https://github.com/cpunion/axum-params\">https://github.com/cpunion/axum-params</a></p> <h2>Motivation</h2> <p>I found myself writing significantly more code in Rust compared to Rails for similar functionality. My Rust controllers were often several times longer, especially when handling file uploads and complex parameter structures. I wanted to streamline this.</p> <h2>What it does</h2> <p>The library provides a Rails-inspired parameter parser that: - Unifies handling of Query/Path/Form/JSON/Multipart parameters - Supports complex tree-like data structures - Handles multiple file objects efficiently - Allows multiple parameter types in a single controller - Currently implements parameter parsing for Axum</p> <h2>Context</h2> <p>While Axum&#39;s extractors are efficient, they have limitations - like not being able to use JSON and Multipart simultaneously since they both consume the request body. File upload handling can also be cumbersome.</p> <h2>Technical Journey</h2> <p>Following my <a href=\"https://www.reddit.com/r/rust/comments/1hl3wxy/how_to_implement_custom_deserialization_for_a/\">previous post</a>, I explored various approaches through Reddit, Stack Overflow, and the Rust Discord community. The main challenge was that we can&#39;t directly deserialize a <code>tokio::fs::File</code> into struct fields. The compromise was to create a pseudo-file object that deserializes temporary file paths and provides an <code>open</code> method to access the file.</p> <h2>Current Limitations</h2> <ol> <li>Due to the indirect file object deserialization, I added a <code>files</code> field in the Params object for automatic cleanup of temporary files. Users need to include an unused &quot;_&quot; parameter in declarations, which feels inelegant.</li> <li>As my first side project in Rust and first published crate, the codebase is partially AI-generated with manual corrections. While functional, I&#39;m uncertain about potential issues.</li> <li>Documentation is currently minimal. I&#39;m curious if others face similar needs and would be interested in collaborating on improvements.</li> </ol> <p>I&#39;d greatly appreciate any feedback, suggestions for improvements, or interest in contributing to the project. Let me know if you&#39;ve faced similar challenges or have ideas for better solutions!</p> </div><!-- SC_ON --> &#32; submitted by &#32; <a href=\"https://www.reddit.com/user/Organic_Savings_6128\"> /u/Organic_Savings_6128 </a> <br/> <span><a href=\"https://www.reddit.com/r/rust/comments/1hnwbut/i_built_a_railslike_parameter_parser_for_axum/\">[link]</a></span> &#32; <span><a href=\"https://www.reddit.com/r/rust/comments/1hnwbut/i_built_a_railslike_parameter_parser_for_axum/\">[comments]</a></span>",
      "flags": null,
      "enclosureUrl": "",
      "enclosureMime": ""
    },
    {
      "title": "$50,000 Rust open source bounties",
      "url": "https://www.reddit.com/r/rust/comments/1hnq2pc/50000_rust_open_source_bounties/",
      "date": 1735336580,
      "author": "/u/ioannisflo",
      "unread": true,
      "content": "<!-- SC_OFF --><div class=\"md\"><p>A list of available Rust OSS bounties on GitHub from <a href=\"http://Algora.io\">Algora.io</a></p> <p>Project: <a href=\"http://Golem.cloud\">Golem.cloud</a></p> <ul> <li>$25,000 <a href=\"https://github.com/golemcloud/golem/issues/1201\">gRPC and OpenAPI Integration</a></li> <li>$10,000 <a href=\"https://github.com/golemcloud/golem/issues/1178\">Develop OpenAPI Export for API Definition</a></li> <li>$5,000 <a href=\"https://github.com/golemcloud/golem/issues/1210\">First-Class Windows Development Environment</a></li> <li>$5,000 <a href=\"https://github.com/golemcloud/golem/issues/1016\">Implement wasm-rdbms interface for standardized database access</a></li> </ul> <p>Project: <a href=\"http://NativeLink.com\">NativeLink.com</a></p> <ul> <li>$2,500 <a href=\"https://github.com/TraceMachina/nativelink/issues/659\">Implement Google Cloud Bucket Store</a></li> <li>$2,000 <a href=\"https://github.com/TraceMachina/nativelink/issues/1542\">Implement an Azure store</a></li> <li>$1,000 <a href=\"https://github.com/TraceMachina/nativelink/issues/1325\">Support digest_function in GrpcStore</a></li> </ul> <p>Project: Screen.pipe</p> <ul> <li>$1,000 <a href=\"https://github.com/mediar-ai/screenpipe/issues/850\">Make RDP work</a></li> </ul> <p>Bounties are paid in USD after pull requests are merged.<br/> These are some of the largest ones available. Happy building!</p> </div><!-- SC_ON --> &#32; submitted by &#32; <a href=\"https://www.reddit.com/user/ioannisflo\"> /u/ioannisflo </a> <br/> <span><a href=\"https://www.reddit.com/r/rust/comments/1hnq2pc/50000_rust_open_source_bounties/\">[link]</a></span> &#32; <span><a href=\"https://www.reddit.com/r/rust/comments/1hnq2pc/50000_rust_open_source_bounties/\">[comments]</a></span>",
      "flags": null,
      "enclosureUrl": "",
      "enclosureMime": ""
    },
    {
      "title": "Stack overflow from early returning from function",
      "url": "https://www.reddit.com/r/rust/comments/1hnhzi4/stack_overflow_from_early_returning_from_function/",
      "date": 1735315265,
      "author": "/u/playbahn",
      "unread": true,
      "content": "<!-- SC_OFF --><div class=\"md\"><p>[SOLVED] EDIT 2: I had an infinitely recursive <code>std::fmt::Display</code> implementation for <code>Tile</code>.</p> <p><a href=\"https://pastebin.com/cEC7etHW\">Full code</a>. I have this method:</p> <pre><code>fn take_step(&amp;self, step: char, map: &amp;Vec&lt;Vec&lt;Tile&gt;&gt;) -&gt; VecDeque&lt;(Self, Self)&gt; { dbg!(&quot;take_step&quot;); let mut shifts: VecDeque&lt;(Self, Self)&gt; = VecDeque::new(); dbg!(&quot;take_step&quot;); if step == &#39; &#39; { dbg!(&quot;take_step&quot;); return shifts; } dbg!(&quot;take_step&quot;); // ... } </code></pre> <p>It&#39;s producing a stack overflow at the <code>return shifts;</code> line. I don&#39;t know why. I couldn&#39;t find anything related to this. I&#39;m calling <code>take_step</code> in a <code>for</code> loop, and <code>step</code> is <code>&#39; &#39;</code> (single space) only once at the starting, and once at the ending. I know I can just not call <code>take_step</code> when <code>step</code> is <code>&#39; &#39;</code>, but still, why is this happenning?</p> <p>EDIT: Tried simply just not calling <code>take_step</code>, still doesn&#39;t work, and I&#39;m still clueless. Changed my <code>for</code> loop to:</p> <pre><code>for step in steps { dbg!(step.1); if *step.1 != &#39; &#39; { shift_coords = robot.take_step(*step.1, &amp;wide_map); } while let Some((from, to)) = shift_coords.pop_back() { wide_map[to.x][to.y] = wide_map[from.x][from.y]; wide_map[from.x][from.y] = Tile::FreeSpace; robot = to; } (0..EDGE).for_each(|y| { (0..EDGE &lt;&lt; 1).for_each(|x| { dbg!(&quot;skjdfn&quot;); print!(&quot;{}&quot;, wide_map[x][y]); dbg!(&quot;skjdfn&quot;); }); dbg!(&quot;skjdfn&quot;); println!(); dbg!(&quot;skjdfn&quot;); }); dbg!(&quot;skjdfn&quot;); } </code></pre> <p>My code now produces a stack overflow at the first execution of <code>print!(&quot;{}&quot;, wide_map[x][y]);</code></p> </div><!-- SC_ON --> &#32; submitted by &#32; <a href=\"https://www.reddit.com/user/playbahn\"> /u/playbahn </a> <br/> <span><a href=\"https://www.reddit.com/r/rust/comments/1hnhzi4/stack_overflow_from_early_returning_from_function/\">[link]</a></span> &#32; <span><a href=\"https://www.reddit.com/r/rust/comments/1hnhzi4/stack_overflow_from_early_returning_from_function/\">[comments]</a></span>",
      "flags": null,
      "enclosureUrl": "",
      "enclosureMime": ""
    },
    {
      "title": "Serde vs Nanoserde - I Created a Benchmark to Compare the Compilation Speed of Serialize & Deserialize Derives of Serde and Nanoserde",
      "url": "https://www.reddit.com/r/rust/comments/1hnftww/serde_vs_nanoserde_i_created_a_benchmark_to/",
      "date": 1735309150,
      "author": "/u/CagatayXx",
      "unread": true,
      "content": "&#32; submitted by &#32; <a href=\"https://www.reddit.com/user/CagatayXx\"> /u/CagatayXx </a> <br/> <span><a href=\"https://github.com/Cugatay/serde-vs-nanoserde\">[link]</a></span> &#32; <span><a href=\"https://www.reddit.com/r/rust/comments/1hnftww/serde_vs_nanoserde_i_created_a_benchmark_to/\">[comments]</a></span>",
      "flags": null,
      "enclosureUrl": "",
      "enclosureMime": ""
    },
    {
      "title": "vite-rs: Embed ViteJS-compiled assets in your Rust binary.",
      "url": "https://www.reddit.com/r/rust/comments/1hneugu/viters_embed_vitejscompiled_assets_in_your_rust/",
      "date": 1735306049,
      "author": "/u/wul-",
      "unread": true,
      "content": "&#32; submitted by &#32; <a href=\"https://www.reddit.com/user/wul-\"> /u/wul- </a> <br/> <span><a href=\"https://github.com/Wulf/vite-rs\">[link]</a></span> &#32; <span><a href=\"https://www.reddit.com/r/rust/comments/1hneugu/viters_embed_vitejscompiled_assets_in_your_rust/\">[comments]</a></span>",
      "flags": null,
      "enclosureUrl": "",
      "enclosureMime": ""
    },
    {
      "title": "Status of the Rust ABI and What Is Going to Change When It's Stabilized",
      "url": "https://www.reddit.com/r/rust/comments/1hnblpt/status_of_the_rust_abi_and_what_is_going_to/",
      "date": 1735293035,
      "author": "/u/CagatayXx",
      "unread": true,
      "content": "<!-- SC_OFF --><div class=\"md\"><p>Hey all, I just wanted to ask two questions.</p> <p>First, what is the current state of the Stable Rust ABI? The questions and debates about this topic are old enough to be asked again IMO.</p> <p>The second question, which has not been asked much, is more important from my perspective. Are the gains from the Rust stable ABI just dreams? The main benefit of the ABI that people say is, that a stable ABI will reduce the compilation time of the language a lot, what do you think about it?</p> <p>Lastly, the reason I&#39;m asking this question is, I think Rust deserves a better compilation time! I just want ideas on how the ABI will change, or will it change, the current state of the Rust language.</p> </div><!-- SC_ON --> &#32; submitted by &#32; <a href=\"https://www.reddit.com/user/CagatayXx\"> /u/CagatayXx </a> <br/> <span><a href=\"https://www.reddit.com/r/rust/comments/1hnblpt/status_of_the_rust_abi_and_what_is_going_to/\">[link]</a></span> &#32; <span><a href=\"https://www.reddit.com/r/rust/comments/1hnblpt/status_of_the_rust_abi_and_what_is_going_to/\">[comments]</a></span>",
      "flags": null,
      "enclosureUrl": "",
      "enclosureMime": ""
    },
    {
      "title": "Error Handling in Rust: Choosing Between thiserror and anyhow",
      "url": "https://www.reddit.com/r/rust/comments/1hn8cqc/error_handling_in_rust_choosing_between_thiserror/",
      "date": 1735278977,
      "author": "/u/CuriousActive2322",
      "unread": true,
      "content": "&#32; submitted by &#32; <a href=\"https://www.reddit.com/user/CuriousActive2322\"> /u/CuriousActive2322 </a> <br/> <span><a href=\"https://medium.com/@evadawnley/error-handling-in-rust-choosing-between-thiserror-and-anyhow-6da5ce825d34\">[link]</a></span> &#32; <span><a href=\"https://www.reddit.com/r/rust/comments/1hn8cqc/error_handling_in_rust_choosing_between_thiserror/\">[comments]</a></span>",
      "flags": null,
      "enclosureUrl": "",
      "enclosureMime": ""
    },
    {
      "title": "This Week in Rust #579",
      "url": "https://www.reddit.com/r/rust/comments/1hn7y8z/this_week_in_rust_579/",
      "date": 1735277521,
      "author": "/u/seino_chan",
      "unread": true,
      "content": "&#32; submitted by &#32; <a href=\"https://www.reddit.com/user/seino_chan\"> /u/seino_chan </a> <br/> <span><a href=\"https://this-week-in-rust.org/blog/2024/12/25/this-week-in-rust-579/\">[link]</a></span> &#32; <span><a href=\"https://www.reddit.com/r/rust/comments/1hn7y8z/this_week_in_rust_579/\">[comments]</a></span>",
      "flags": null,
      "enclosureUrl": "",
      "enclosureMime": ""
    },
    {
      "title": "How to pass a vector to a function without altering the original vector",
      "url": "https://www.reddit.com/r/rust/comments/1hn29xj/how_to_pass_a_vector_to_a_function_without/",
      "date": 1735259073,
      "author": "/u/__Macaroon__",
      "unread": true,
      "content": "<!-- SC_OFF --><div class=\"md\"><p>This is my code:</p> <pre><code>fn main() { let mut v = vec![1, 3, 2, 4, 1, 2, 3, 3, 4, 4, 4, 4, 1]; println!(&quot;{}&quot;, median(v.as_mut_slice())); println!(&quot;{v:?}&quot;); } fn median(list: &amp;mut [i32]) -&gt; i32 { list.sort(); list[list.len() / 2] } </code></pre> <p>This works for finding the median value, but it feels unsatisfying that I can&#39;t seem to figure out how to find the median value of a vector without changing it. Many thanks!</p> </div><!-- SC_ON --> &#32; submitted by &#32; <a href=\"https://www.reddit.com/user/__Macaroon__\"> /u/__Macaroon__ </a> <br/> <span><a href=\"https://www.reddit.com/r/rust/comments/1hn29xj/how_to_pass_a_vector_to_a_function_without/\">[link]</a></span> &#32; <span><a href=\"https://www.reddit.com/r/rust/comments/1hn29xj/how_to_pass_a_vector_to_a_function_without/\">[comments]</a></span>",
      "flags": null,
      "enclosureUrl": "",
      "enclosureMime": ""
    },
    {
      "title": "Jiff (datetime library for Rust) now supports a \"friendly\" duration format as an alternative to the `humantime` crate",
      "url": "https://www.reddit.com/r/rust/comments/1hmwsmt/jiff_datetime_library_for_rust_now_supports_a/",
      "date": 1735243784,
      "author": "/u/burntsushi",
      "unread": true,
      "content": "&#32; submitted by &#32; <a href=\"https://www.reddit.com/user/burntsushi\"> /u/burntsushi </a> <br/> <span><a href=\"https://docs.rs/jiff/latest/jiff/fmt/friendly/index.html\">[link]</a></span> &#32; <span><a href=\"https://www.reddit.com/r/rust/comments/1hmwsmt/jiff_datetime_library_for_rust_now_supports_a/\">[comments]</a></span>",
      "flags": null,
      "enclosureUrl": "",
      "enclosureMime": ""
    },
    {
      "title": "Trying to make the fastest card drawer possible, why is my second implementation slower?",
      "url": "https://www.reddit.com/r/rust/comments/1hmu6ax/trying_to_make_the_fastest_card_drawer_possible/",
      "date": 1735236713,
      "author": "/u/CrimzonGryphon",
      "unread": true,
      "content": "<!-- SC_OFF --><div class=\"md\"><p>Disclaimer: I&#39;m new to rust.</p> <p>Hey I&#39;ve been looking at making a poker evaluator. Part of this involves generating random hands. I&#39;ve discovered that my random hand generator is a performance consideration. I used naive assumptions like &#39;stack allocations and accesses are going to be super fast&#39; and &#39;the less branching the better&#39; but have found some strange behaviours.</p> <p>I would say the behaviour the confuses me most is that moving the <code>existing_cards.push(X)</code> logic into a separate loop over <code>taken</code> is actually slower (seemingly about 1.2x the time, could potentially be chance).</p> <p>Can I get some suggestions on how to improve performance further, and justifications of why my slower implementations are slower.</p> <p>This is how I&#39;ve been benchmarking: </p> <pre><code>#[test] fn test_new_random_cards_performance() { let start = Instant::now(); for _ in 0..100_000 { _ = Card::new_random_cards(5); } let duration = start.elapsed(); println!(&quot;Time taken to generate 5 random cards 100k times: {:?}&quot;, duration); assert!(duration.as_millis() &lt; 500, &quot;Performance test failed: took too long to generate cards&quot;); } </code></pre> <p>Fastest I&#39;ve achieved (about 1.5-2x faster than the non-branching implementation, 1.2x the 2-loop implementation):</p> <pre><code>pub fn new_random_cards(num_cards: usize) -&gt; Vec&lt;Card&gt; { let mut taken = [false; 52]; let mut existing_cards = Vec::with_capacity(num_cards); let rng = &amp;mut SmallRng::from_entropy(); while existing_cards.len() &lt; num_cards { let card_int = rng.gen::&lt;usize&gt;() % 52; if taken[card_int] { continue; } taken[card_int] = true; existing_cards.push(Card::from_int(card_int as u8)); } existing_cards } </code></pre> <p>Slower implementation which is effectively the same but I thought the CPU would optimise: </p> <pre><code>pub fn new_random_cards2(mut num_cards: usize) -&gt; Vec&lt;Card&gt; { let mut taken = [false; 52]; let rng = &amp;mut SmallRng::from_entropy(); while num_cards &gt; 0 { let card_int = rng.gen::&lt;usize&gt;() % 52; if taken[card_int] { continue; } taken[card_int] = true; num_cards -= 1 } let mut existing_cards = Vec::with_capacity(num_cards); for card_int in 0..52 { if existing_cards.len() &gt;= num_cards { break; } if !taken[card_int] { existing_cards.push(Card::from_int(card_int as u8)); } } existing_cards } </code></pre> <p>Even slower non-branching implementation:</p> <pre><code>pub fn new_random_cards(mut num_cards: u8) -&gt; Vec&lt;Card&gt; { let mut taken = [0u8; 52]; let rng = &amp;mut SmallRng::from_entropy(); while num_cards &gt; 0 { let card_int = rng.gen::&lt;usize&gt;() % 52; let change = 1 - taken[card_int]; num_cards -= change; taken[card_int] += change; } let mut res = Vec::with_capacity(num_cards as usize); for i in 0..52 { if taken[i] == 1 { res.push(Card::from_int(i as u8)); } } res } </code></pre> <p>In terms of implementation, the Card is just an struct with a Suit and Rank enum. Various helper methods convert ints into cards, suits, ranks.</p> </div><!-- SC_ON --> &#32; submitted by &#32; <a href=\"https://www.reddit.com/user/CrimzonGryphon\"> /u/CrimzonGryphon </a> <br/> <span><a href=\"https://www.reddit.com/r/rust/comments/1hmu6ax/trying_to_make_the_fastest_card_drawer_possible/\">[link]</a></span> &#32; <span><a href=\"https://www.reddit.com/r/rust/comments/1hmu6ax/trying_to_make_the_fastest_card_drawer_possible/\">[comments]</a></span>",
      "flags": null,
      "enclosureUrl": "",
      "enclosureMime": ""
    },
    {
      "title": "Cross crate dependencies: How does Rust avoid duplicate types?",
      "url": "https://www.reddit.com/r/rust/comments/1hmshtr/cross_crate_dependencies_how_does_rust_avoid/",
      "date": 1735232173,
      "author": "/u/deavidsedice",
      "unread": true,
      "content": "<!-- SC_OFF --><div class=\"md\"><p>Say for example you have a project that uses <code>ndarray</code>, <code>ndarray-conv</code> and <code>ndarray-linalg</code> (Let&#39;s ignore for a second that <code>ndarray-linalg</code> does not work yet with <code>ndarray</code> 0.16).</p> <p>Each of these (<code>ndarray-conv</code> and <code>ndarray-linalg</code>) will import <code>ndarray</code> internally, and it will be declared on their Cargo.toml.</p> <p>My common sense says that each of these would just see their own version of the <code>ndarray</code> types and not extend the original crate, for example when adding traits. However, this is not the case. It does work... most of the time.</p> <p>I&#39;ve also seen that they get different instances of the base types, and then you get surprised that the traits or functions don&#39;t work with your base types. So far this has been on different major versions (0.15 vs 0.16) I think.</p> <p>But then I see the Cargo.toml of these libraries and I see things like <code>ndarray = &#39;0.16.0&#39;</code> and it seems to work with ndarray 0.16.1 too. I&#39;m confused. How does this work?</p> <p>So I&#39;m looking for a few things here:</p> <p>1) An in-depth explanation on how this mechanism of joining the crates together works. 2) Does it ever refuse to build on dependency checking? It never happened to me, I never got an error from <code>cargo</code> saying that crate X and Y are incompatible for this reason. 3) Is there any eyes on making this more flexible? Meaning, attempting to join different major crate versions and see if the libraries still build, because after all we&#39;re still building all the source code.</p> <p>Not trying to solve any problem. I&#39;m just curious.</p> </div><!-- SC_ON --> &#32; submitted by &#32; <a href=\"https://www.reddit.com/user/deavidsedice\"> /u/deavidsedice </a> <br/> <span><a href=\"https://www.reddit.com/r/rust/comments/1hmshtr/cross_crate_dependencies_how_does_rust_avoid/\">[link]</a></span> &#32; <span><a href=\"https://www.reddit.com/r/rust/comments/1hmshtr/cross_crate_dependencies_how_does_rust_avoid/\">[comments]</a></span>",
      "flags": null,
      "enclosureUrl": "",
      "enclosureMime": ""
    },
    {
      "title": "Tackler accounting tool goes from Scala to Rust",
      "url": "https://www.reddit.com/r/rust/comments/1hmp33b/tackler_accounting_tool_goes_from_scala_to_rust/",
      "date": 1735222233,
      "author": "/u/35VLG84",
      "unread": true,
      "content": "&#32; submitted by &#32; <a href=\"https://www.reddit.com/user/35VLG84\"> /u/35VLG84 </a> <br/> <span><a href=\"https://github.com/e257-fi/tackler-ng\">[link]</a></span> &#32; <span><a href=\"https://www.reddit.com/r/rust/comments/1hmp33b/tackler_accounting_tool_goes_from_scala_to_rust/\">[comments]</a></span>",
      "flags": null,
      "enclosureUrl": "",
      "enclosureMime": ""
    }
  ]
}