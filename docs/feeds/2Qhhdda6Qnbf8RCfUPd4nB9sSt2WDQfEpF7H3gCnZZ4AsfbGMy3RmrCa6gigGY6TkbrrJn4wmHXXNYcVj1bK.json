{"id":"2Qhhdda6Qnbf8RCfUPd4nB9sSt2WDQfEpF7H3gCnZZ4AsfbGMy3RmrCa6gigGY6TkbrrJn4wmHXXNYcVj1bK","title":"top scoring links : rust","displayTitle":"Reddit - Rust","url":"https://www.reddit.com/r/rust/top/.rss?sort=top&t=day&limit=6","feedLink":"https://www.reddit.com/r/rust/top/?sort=top&t=day&limit=6","items":[{"title":"Error Handling in Rust: Choosing Between thiserror and anyhow","url":"https://www.reddit.com/r/rust/comments/1hn8cqc/error_handling_in_rust_choosing_between_thiserror/","date":1735278977,"author":"/u/CuriousActive2322","unread":true,"desc":"","content":"&#32; submitted by &#32; <a href=\"https://www.reddit.com/user/CuriousActive2322\"> /u/CuriousActive2322 </a> <br/> <span><a href=\"https://medium.com/@evadawnley/error-handling-in-rust-choosing-between-thiserror-and-anyhow-6da5ce825d34\">[link]</a></span> &#32; <span><a href=\"https://www.reddit.com/r/rust/comments/1hn8cqc/error_handling_in_rust_choosing_between_thiserror/\">[comments]</a></span>","flags":null,"enclosureUrl":"","enclosureMime":""},{"title":"This Week in Rust #579","url":"https://www.reddit.com/r/rust/comments/1hn7y8z/this_week_in_rust_579/","date":1735277521,"author":"/u/seino_chan","unread":true,"desc":"","content":"&#32; submitted by &#32; <a href=\"https://www.reddit.com/user/seino_chan\"> /u/seino_chan </a> <br/> <span><a href=\"https://this-week-in-rust.org/blog/2024/12/25/this-week-in-rust-579/\">[link]</a></span> &#32; <span><a href=\"https://www.reddit.com/r/rust/comments/1hn7y8z/this_week_in_rust_579/\">[comments]</a></span>","flags":null,"enclosureUrl":"","enclosureMime":""},{"title":"How to pass a vector to a function without altering the original vector","url":"https://www.reddit.com/r/rust/comments/1hn29xj/how_to_pass_a_vector_to_a_function_without/","date":1735259073,"author":"/u/__Macaroon__","unread":true,"desc":"","content":"<!-- SC_OFF --><div class=\"md\"><p>This is my code:</p> <pre><code>fn main() { let mut v = vec![1, 3, 2, 4, 1, 2, 3, 3, 4, 4, 4, 4, 1]; println!(&quot;{}&quot;, median(v.as_mut_slice())); println!(&quot;{v:?}&quot;); } fn median(list: &amp;mut [i32]) -&gt; i32 { list.sort(); list[list.len() / 2] } </code></pre> <p>This works for finding the median value, but it feels unsatisfying that I can&#39;t seem to figure out how to find the median value of a vector without changing it. Many thanks!</p> </div><!-- SC_ON --> &#32; submitted by &#32; <a href=\"https://www.reddit.com/user/__Macaroon__\"> /u/__Macaroon__ </a> <br/> <span><a href=\"https://www.reddit.com/r/rust/comments/1hn29xj/how_to_pass_a_vector_to_a_function_without/\">[link]</a></span> &#32; <span><a href=\"https://www.reddit.com/r/rust/comments/1hn29xj/how_to_pass_a_vector_to_a_function_without/\">[comments]</a></span>","flags":null,"enclosureUrl":"","enclosureMime":""},{"title":"Jiff (datetime library for Rust) now supports a \"friendly\" duration format as an alternative to the `humantime` crate","url":"https://www.reddit.com/r/rust/comments/1hmwsmt/jiff_datetime_library_for_rust_now_supports_a/","date":1735243784,"author":"/u/burntsushi","unread":true,"desc":"","content":"&#32; submitted by &#32; <a href=\"https://www.reddit.com/user/burntsushi\"> /u/burntsushi </a> <br/> <span><a href=\"https://docs.rs/jiff/latest/jiff/fmt/friendly/index.html\">[link]</a></span> &#32; <span><a href=\"https://www.reddit.com/r/rust/comments/1hmwsmt/jiff_datetime_library_for_rust_now_supports_a/\">[comments]</a></span>","flags":null,"enclosureUrl":"","enclosureMime":""},{"title":"Trying to make the fastest card drawer possible, why is my second implementation slower?","url":"https://www.reddit.com/r/rust/comments/1hmu6ax/trying_to_make_the_fastest_card_drawer_possible/","date":1735236713,"author":"/u/CrimzonGryphon","unread":true,"desc":"","content":"<!-- SC_OFF --><div class=\"md\"><p>Disclaimer: I&#39;m new to rust.</p> <p>Hey I&#39;ve been looking at making a poker evaluator. Part of this involves generating random hands. I&#39;ve discovered that my random hand generator is a performance consideration. I used naive assumptions like &#39;stack allocations and accesses are going to be super fast&#39; and &#39;the less branching the better&#39; but have found some strange behaviours.</p> <p>I would say the behaviour the confuses me most is that moving the <code>existing_cards.push(X)</code> logic into a separate loop over <code>taken</code> is actually slower (seemingly about 1.2x the time, could potentially be chance).</p> <p>Can I get some suggestions on how to improve performance further, and justifications of why my slower implementations are slower.</p> <p>This is how I&#39;ve been benchmarking: </p> <pre><code>#[test] fn test_new_random_cards_performance() { let start = Instant::now(); for _ in 0..100_000 { _ = Card::new_random_cards(5); } let duration = start.elapsed(); println!(&quot;Time taken to generate 5 random cards 100k times: {:?}&quot;, duration); assert!(duration.as_millis() &lt; 500, &quot;Performance test failed: took too long to generate cards&quot;); } </code></pre> <p>Fastest I&#39;ve achieved (about 1.5-2x faster than the non-branching implementation, 1.2x the 2-loop implementation):</p> <pre><code>pub fn new_random_cards(num_cards: usize) -&gt; Vec&lt;Card&gt; { let mut taken = [false; 52]; let mut existing_cards = Vec::with_capacity(num_cards); let rng = &amp;mut SmallRng::from_entropy(); while existing_cards.len() &lt; num_cards { let card_int = rng.gen::&lt;usize&gt;() % 52; if taken[card_int] { continue; } taken[card_int] = true; existing_cards.push(Card::from_int(card_int as u8)); } existing_cards } </code></pre> <p>Slower implementation which is effectively the same but I thought the CPU would optimise: </p> <pre><code>pub fn new_random_cards2(mut num_cards: usize) -&gt; Vec&lt;Card&gt; { let mut taken = [false; 52]; let rng = &amp;mut SmallRng::from_entropy(); while num_cards &gt; 0 { let card_int = rng.gen::&lt;usize&gt;() % 52; if taken[card_int] { continue; } taken[card_int] = true; num_cards -= 1 } let mut existing_cards = Vec::with_capacity(num_cards); for card_int in 0..52 { if existing_cards.len() &gt;= num_cards { break; } if !taken[card_int] { existing_cards.push(Card::from_int(card_int as u8)); } } existing_cards } </code></pre> <p>Even slower non-branching implementation:</p> <pre><code>pub fn new_random_cards(mut num_cards: u8) -&gt; Vec&lt;Card&gt; { let mut taken = [0u8; 52]; let rng = &amp;mut SmallRng::from_entropy(); while num_cards &gt; 0 { let card_int = rng.gen::&lt;usize&gt;() % 52; let change = 1 - taken[card_int]; num_cards -= change; taken[card_int] += change; } let mut res = Vec::with_capacity(num_cards as usize); for i in 0..52 { if taken[i] == 1 { res.push(Card::from_int(i as u8)); } } res } </code></pre> <p>In terms of implementation, the Card is just an struct with a Suit and Rank enum. Various helper methods convert ints into cards, suits, ranks.</p> </div><!-- SC_ON --> &#32; submitted by &#32; <a href=\"https://www.reddit.com/user/CrimzonGryphon\"> /u/CrimzonGryphon </a> <br/> <span><a href=\"https://www.reddit.com/r/rust/comments/1hmu6ax/trying_to_make_the_fastest_card_drawer_possible/\">[link]</a></span> &#32; <span><a href=\"https://www.reddit.com/r/rust/comments/1hmu6ax/trying_to_make_the_fastest_card_drawer_possible/\">[comments]</a></span>","flags":null,"enclosureUrl":"","enclosureMime":""},{"title":"Tackler accounting tool goes from Scala to Rust","url":"https://www.reddit.com/r/rust/comments/1hmp33b/tackler_accounting_tool_goes_from_scala_to_rust/","date":1735222233,"author":"/u/35VLG84","unread":true,"desc":"","content":"&#32; submitted by &#32; <a href=\"https://www.reddit.com/user/35VLG84\"> /u/35VLG84 </a> <br/> <span><a href=\"https://github.com/e257-fi/tackler-ng\">[link]</a></span> &#32; <span><a href=\"https://www.reddit.com/r/rust/comments/1hmp33b/tackler_accounting_tool_goes_from_scala_to_rust/\">[comments]</a></span>","flags":null,"enclosureUrl":"","enclosureMime":""}]}